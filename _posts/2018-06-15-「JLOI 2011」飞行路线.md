---
title: 「JLOI 2011」飞行路线
date: 2018-06-15 18:50:14
categories:
- 最短路
tags:
- 分层图
mathjax: true
---

> 题目大意：给出一个 $n$ 个结点 $m$ 条边的无向图，每条边有一个权值，要求从起点走到终点，可将途中 $k$ 条边的权值变为 0，问路径的最小权值和为多少。$2<=n<=10000, 1<=m<=50000, 0<=k<=10$

由于 $k$ 很小，可以考虑拆点，用 dp 的思想，将每个点拆成 $k + 1$ 个点 $(i,j)$，分别表示从起点到点 $i$ 使用了 $j∈[0,k]$ 次免权值，建图时 $(u,j)->(v,j)$ 权值为 $c$，$(u,j)->(v,j+1)$ 权值为 $0$，跑最短路。

```c++
#include <cstdio>
#include <queue>
#include <vector>
#include <cstring>

const int N = 200005, INF = 0x3f3f3f3f;
struct Edge {
	int from, to, cost;
};
std::vector<Edge> edges;
std::vector<int> G[N];
int n, m, s, t, k, dis[N];
bool vis[N];
struct Node {
	int val, pos;
	bool operator > (const Node &cmp) const {
		return val > cmp.val;
	}
};
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return x * f;
}
int min(int x, int y) {
	return x < y ? x : y;
}
void add_edge(int from, int to, int cost) {
	G[from].push_back(edges.size());
	edges.push_back((Edge){from, to, cost});
}
void dfs(int u, int fa) {
	vis[u] = 1;
	int sz = G[u].size();
	for (int i = 0; i < sz; ++i) {
		Edge e = edges[G[u][i]];
		for (int j = 0; j <= k; ++j) {
			add_edge(u + j * n, e.to + j * n, e.cost);
			add_edge(u + j * n, e.to + (j + 1) * n, 0);
		}
		if (!vis[e.to]) dfs(e.to, u);
	}
}
int dij() {
	std::priority_queue<Node, std::vector<Node>, std::greater<Node> > Q;
	memset(dis, 0x3f, sizeof dis); dis[s] = 0;
	int vis[N] = {}; Q.push((Node){0, s});
	while (!Q.empty()) {
		int u = Q.top().pos, sz = G[u].size();
		Q.pop(), vis[u] = 1;
		for (int i = 0; i < sz; ++i) {
			Edge e = edges[G[u][i]];
			if (!vis[e.to] && dis[u] + e.cost < dis[e.to])
				dis[e.to] = dis[u] + e.cost, Q.push((Node){dis[e.to], e.to});
		}
	}
}

int main() {
	n = read(), m = read(), k = read(), s = read() + 1, t = read() + 1;
	while (m--) {
		int u = read() + 1, v = read() + 1, c = read();
		add_edge(u, v, c), add_edge(v, u, c);
	}
	dfs(s, 0); dij();
	int ans = INF;
	for (int i = 0; i <= k; ++i)
		ans = min(ans, dis[t+i*n]);
	printf("%d\n", ans);
	return 0;
}
```
