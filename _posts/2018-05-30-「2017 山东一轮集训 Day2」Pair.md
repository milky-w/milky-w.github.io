---
title: 「2017 山东一轮集训 Day2」Pair
date: 2018-05-30 14:49:56
categories:
- 线段树
- 网络流
tags:
- 霍尔定理
mathjax: true
---

> 题目大意：给出一个长度为 $n$ 的数列 $\lbrace a_i \rbrace$ 和一个长度为 $m$ 的数列 $\lbrace b_i \rbrace$，求 $\lbrace a_i \rbrace$ 有多少个长度为 $m$ 的连续子数列能与 $\lbrace b_i \rbrace$ 匹配。两个数列可以匹配，当且仅当存在一种方案，使两个数列中的数可以两两配对，两个数可以配对当且仅当它们的和不小于 $h$。
$1≤m≤n≤150000$，$1≤a_i,b_i,h≤10^9$

我一开始这样想：先将两个序列都升序排序一遍，$O(mlogn)$ 预处理，对于 $\lbrace b_i \rbrace$ 中每个元素在 $\lbrace a_i \rbrace$ 中二分查找第一个大于等于 $k-b_i$ 的位置，每个 $b_i$ 向从这个位置开始往后的 $a_i$ 连边，用一个数组存每个 $b_i$ 的这个位置，$ans$ 初始值为 $b_1$，扫描整个数组，如果出现非升序就 $－－ans$…… 然后发现这样好像只能处理 $\lbrace a_i \rbrace$ 升序的情况……

然后我又想了一个 $m=n$ 的部分分做法：将 $\lbrace b_i \rbrace$ 排序，$O(nlogm)$ 预处理，对于每个 $a_i$ 二分找 $\lbrace b_i \rbrace$ 中 $k-a_i$ 的位置 $p_i$，然后开一个桶 $tub$，$++tub[p_i]$，都处理完以后做桶的前缀和，如果每个 $sum[i]>=i$，则符合条件。

想正解想了一上午，我很快推出将 $\lbrace b_i \rbrace$ 降序排序后，每个 $a_i$ 可以匹配的都是一段前缀，扫描线从前至后扫序列 $\lbrace a_i \rbrace$，设当前区间为 $[l,r]$，每次用线段树给 $a_r$ 所对应的前缀 $+1$，给 $a_{l-1}$ 所对应的前缀 $-1$，这段区间符合条件当且仅当在线段树中，所有的叶子节点的值 $>=$ 节点编号。

然后我就一直想啊，怎么 $O(logn)$ 判断每个叶子节点的值都大于它的编号啊？

一上午过去了……

中午的时候才发现只要让每个叶子节点都减去它的编号，即初始化为编号的相反数，判断最小值是否大于 $0$ 就可以了……

![](http://images.cnblogs.com/cnblogs_com/milky-w/1226322/o_QQ%e5%9b%be%e7%89%8720180531125119.jpg)
