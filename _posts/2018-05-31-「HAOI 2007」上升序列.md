---
title: 「HAOI 2007」上升序列
date: 2018-05-31 17:38:09
categories:
- 动态规划
mathjax: true
---

> 给定一个长为 $N$ 的序列，$M$ 次求任意长度的上升子序列，要求字典序最小（这里的字典序是位置最小）。$N<=10000,M<=1000$

肯定与 $nlogn$ 最长上升子序列相关，先倒着求一遍最长上升子序列，$f[i]$ 表示以第 $i$ 位开始的最长上升子序列长度。

因为是字典序位置最小，所以从前往后贪心就可以了。

```c++
#include <cstdio>
#include <string>
#include <algorithm>

const int N = 10005;
int f[N], d[N], a[N], len, n;

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (!isdigit(c)) {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (isdigit(c)) {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
int max(int x, int y) {
    if (x >= y) return x; return y;
}
int find(int x) {
    int l = 1, r = len, res = 0;
    while (l <= r) {
        int mid = l + (r - l >> 1);
        if (d[mid] > x) res = mid, l = mid + 1;
        else r = mid - 1;
    }
    return res;
}
void fly(int x) {
    int last = 0;
    for (int i = 1; i <= n; ++i) {
        if (f[i] >= x && a[i] > last) {
            printf("%d ", a[i]);
            last = a[i], --x;
            if (!x) break;
        }
    }
    puts("");
}
int main() {
    n = read();
    for (int i = 1; i <= n; ++i) a[i] = read();
    for (int i = n; i; --i) {
        int t = find(a[i]);
        f[i] = t + 1, len = max(len, f[i]);
        if (d[t+1] < a[i]) d[t+1] = a[i];
    }
    int m = read();
    while (m--) {
        int x = read();
        if (x <= len) fly(x);
        else puts("Impossible");
    }
    return 0;
}
```
