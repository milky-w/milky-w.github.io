---
title: 「NOI 2014」动物园
date: 2018-06-15 19:33:05
categories:
- 字符串
tags:
- KMP
mathjax: true
---

> 题目大意：$num[i]$ 表示字符串 $S$ 的前 $i$ 位有多少个不重叠的公共前后缀，输出 $\prod_{i=1}^{\|S\|}(num[i]+1)$。$1≤\|S\|≤10^6$

明确：$nxt[i]$ 表示前缀 $i$ 的最长公共前后缀的长度（可重叠但不包含后缀 $i$ 本身），$nxt[nxt[i]]$ 也是后缀 $i$ 的公共前后缀。

性质：$nxt[i]$ 最多比 $nxt[i-1]$ 大 $1$；设不重叠的最长公共前后缀的长度为 $num[i]$，则 $num[i]$ 最多比 $num[i-1]$ 大 $1$，且可以远小于 $nxt[i]$，所以代码中当前 $j$ 初始化为 $num[i-1]$ 而非 $nxt[i]$。

```c++
#include <cstdio>
#include <cstring>

const int N = 1000010, P = 1e9 + 7;
int nxt[N], num[N], n;
long long ans;
char s[N];

void get_next() {
    nxt[0] = nxt[1] = 0, num[1] = 1;
    for (int i = 1; i < n; ++ i) {
        int j = nxt[i];
        while (j && s[i] != s[j]) j = nxt[j];
        nxt[i+1] = s[i] == s[j] ? j + 1 : 0;
        num[i+1] = num[nxt[i+1]] + 1;
    }
}
void KMP() {
    get_next();
    int j = 0;
    for (int i = 0; i < n; ++ i) {
        while (j && s[i] != s[j]) j = nxt[j];
        if (s[i] == s[j]) ++j;
        while (j && j > (i + 1 >> 1)) j = nxt[j];
        ans *= (1LL) * (num[j] + 1);
        if (ans >= P) ans %= P;
    }
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%s", s);
        n = strlen(s), ans = 1;
        KMP();
        printf("%d\n", ans);
    }
    return 0;
}
```
