---
title: 「USACO 16 OPEN」262144
date: 2018-05-28 21:07:05
categories:
- 动态规划
tags:
- 区间DP
---

> 题目大意：给定一个 1*n 的地图，在里面玩 2048，每次可以合并相邻两个（数值范围 1-40），问最大能合出多少。注意合并后的数值并非加倍而是 +1，例如 2 与 2 合并后的数值为 3。

> 数据范围：2≤N≤262144

我的DP好弱啊。。没有想出来。。看完题解感觉好厉害呀。。

因为合并一定是连续的，设 <a href="http://www.codecogs.com/eqnedit.php?latex=\inline&space;f[i][j]" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\inline&space;f[i][j]" title="f[i][j]" /></a> 表示从左端点 <a href="http://www.codecogs.com/eqnedit.php?latex=i" target="_blank"><img src="http://latex.codecogs.com/gif.latex?i" title="i" /></a> 开始合并，合并出 <a href="http://www.codecogs.com/eqnedit.php?latex=j" target="_blank"><img src="http://latex.codecogs.com/gif.latex?j" title="j" /></a> 这个数时的右端点下标 <a href="http://www.codecogs.com/eqnedit.php?latex=&plus;1" target="_blank"><img src="http://latex.codecogs.com/gif.latex?&plus;1" title="+1" /></a>。有：


<a href="http://www.codecogs.com/eqnedit.php?latex=f[i][j]&space;=&space;f[f[i][j-1]][j-1]" target="_blank"><img src="http://latex.codecogs.com/gif.latex?f[i][j]&space;=&space;f[f[i][j-1]][j-1]" title="f[i][j] = f[f[i][j-1]][j-1]" /></a>

```c++
#include <cstdio>

int f[262150][60];

int read() {
    int x = 0; char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }
    return x;
}

int main() {
    int n = read(), ans = 0;
    for (int i = 1; i <= n; ++i) {
        int x = read();
        f[i][x] = i + 1;
    }
    for (int j = 2; j <= 58; ++j)
        for (int i = 1; i <= n; ++i) {
            if (!f[i][j]) f[i][j] = f[f[i][j-1]][j-1];
            if (f[i][j]) ans = j;
        }
    printf("%d\n", ans);
    return 0;
}
```
