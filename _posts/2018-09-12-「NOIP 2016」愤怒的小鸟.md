---
title: 「NOIP 2016」愤怒的小鸟
date: 2018-09-12 10:33:00
categories:
- OI
tags:
- 状压DP
mathjax: true
---

> 题目大意：第一象限上有 $n$ 只小猪，第 $i$ 只小猪的坐标为 $(x_i,y_i)$，每一只小鸟的起点为 $(0,0)$，飞行路线为 $a_ix^2+b_ix$，其中 $a_i,b_i$ 是自定义的参数，且 $a_i<0$，每一只小鸟会消灭所有在它飞行路线上的小猪，问消灭全部的小猪最少使用多少只小鸟？$n \leq 18, 0 <x_i,y_i<10$

暴力 $dfs$ 有 $70$ 分，枚举当前元素在前面的哪一个集合里，并判断在不在该集合元素组成的抛物线上，或者自己单独新开一个集合，$n=12$ 时，复杂度最多为 $O(4213597)$。

预处理出任意两个点与原点所构成的抛物线，因为我们所用到的飞行路线只可能在这些抛物线中产生，设 $g[i]$ 表示第 $i$ 条抛物线经过了哪几头猪。

然后 $1 \cdots 2^n$ 枚举打下的猪的状态，设 $f[i]$ 表示打下状态 $i$ 的猪最少需要多少只鸟，有状态转移方程：

$$
f[i|g[j]]=\min(f[i|g[j]], f[i]+1)
$$

即 $f[i]$ 最多再用一只鸟就可以转移到 $f[i|g[j]]$。

多组数据注意初始化。

```c++
#include <cstdio>
#include <cstring>

struct Node {
    double x, y;
} c[20];

int f[262150], g[400], vis[20], n, m;

int min(int x, int y) {
    return x < y ? x : y;
}
int dcmp(double x, double y) {
    if (x - y >= 0.00000001) return 1;
    if (y - x >= 0.00000001) return -1;
    return 0;
}
void calc(double x1, double y1, double x2, double y2) {
    double a = (x2 * y1 - x1 * y2) / (x1 * x2 * (x1 - x2));
    if (a >= 0) return;
    double b = y1 / x1 - a * x1; ++g[0];
    for (int i = 1; i <= n; ++i)
        if (dcmp(a * c[i].x * c[i].x + b * c[i].x, c[i].y) == 0)
            g[g[0]] |= 1 << i - 1, vis[i] = 1;
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i) scanf("%lf%lf", &c[i].x, &c[i].y);
        memset(g, 0, sizeof g); //不要忘记memset
        memset(vis, 0, sizeof vis);
        for (int i = 1; i < n; ++i) //预处理抛物线
            for (int j = i + 1; j <= n; ++j)
                if (c[i].x != c[j].x) calc(c[i].x, c[i].y, c[j].x, c[j].y); //横坐标相等直接判掉
        for (int i = 1; i <= n; ++i) //一个点单独一个抛物线的情况
            if (!vis[i]) g[++g[0]] = 1 << i - 1;
        int tot = (1 << n) - 1;
        memset(f, 0x3f, sizeof f);
        f[0] = 0;
        for (int i = 0; i <= tot; ++i) //枚举状态
            for (int j = 1; j <= g[0]; ++j) //枚举抛物线
                f[i|g[j]] = min(f[i|g[j]], f[i] + 1);
        printf("%d\n", f[tot]);
    }
    return 0;
}
```

时间复杂度 $O(2^nn^2)$