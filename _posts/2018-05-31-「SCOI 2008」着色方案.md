---
title: 「SCOI 2008」着色方案
date: 2018-05-31 13:57:48
categories:
- 动态规划
tags:
- 记忆化搜索
mathjax: true
---

> 题目大意：有 $n$ 个木块排成一行，从左到右依次编号为 $1\cdots n$。你有 $k$ 种颜色的油漆，其中第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。所有油漆刚好足够涂满所有木块，即 $c_1+c_2+...+c_k=n$。统计任意两个相邻木块颜色不同的着色方案，输出方案数模 $1,000,000,007$ 的结果。$1 <= k <= 15, 1 <= c_i <= 5$

感觉这个数据范围非常玄学…… 之前做过但是再做还是不会啊……

重新参悟题解，我这次一定不要再忘了……

$f[a][b][c][d][e][x]$ 表示目前还能涂 $1$ 次的颜色有 $a$ 个，能涂 $2$ 次的颜色有 $b$ 个…… 上一次用的是能涂 $x$ 次的颜色。记搜程序段如下：

```c++
long long dp(int a, int b, int c, int d, int e, int co) {
    long long ans = 0;
    int i;
    if (a < 0 || b < 0 || c < 0 || d < 0 || e < 0) return 0;
    if (!a && !b && !c && !d && !e) return 1;
    if (visit[a][b][c][d][e][co]) return f[a][b][c][d][e][co];
    ans = (ans + (a - (co == 2)) * dp(a - 1, b, c, d, e, 1)) % inf;
    ans = (ans + (b - (co == 3)) * dp(a + 1, b - 1, c, d, e, 2)) % inf;
    ans = (ans + (c - (co == 4)) * dp(a, b + 1, c - 1, d, e, 3)) % inf;
    ans = (ans + (d - (co == 5)) * dp(a, b, c + 1, d - 1, e, 4)) % inf;
    ans = (ans + e * dp(a, b, c, d + 1, e - 1, 5)) % inf;
    visit[a][b][c][d][e][co] = true;
    return f[a][b][c][d][e][co] = ans;
}
```

这个思路非常妙，它把当前能涂的次数相同的颜色放在一起处理了，因为它们之间是没有差异性的。

这是一种典型的用次数进行状态转移，不妨记做“着色方案型DP”。

---

就在我刚刚关了洛谷的题面，Asia指着我的电脑屏幕开心地说：“你刚才看的那个紫题，它绝对不是一道紫题，顶多是一道黄题(≧∀≦)ゞ”

<center> …… </center>

![](http://images.cnblogs.com/cnblogs_com/milky-w/1226322/o_QQ%e5%9b%be%e7%89%8720180531155607.jpg)
