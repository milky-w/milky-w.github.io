---
title: 「NOIP 2017」逛公园
date: 2018-06-15 18:35:38
categories:
- 动态规划
tags:
- 记忆化搜索
mathjax: true
---

> 题目大意：给定一张 $N$ 个点 $M$ 条边的有向图，问从点 $1$ 到点 $N$ 有多少条长度不超过最短路 + $K$ 的路径，输出答案模 $P$ 的结果，如果有无穷多条则输出 $-1$。$1≤N≤10^5，1≤M≤2*10^5，1≤P≤10^9，0≤c_i≤1000$

求出每个点到起点的最短距离，然后记忆化搜索。

用 $f[i]$ 表示结点 $i$ 到终点的合法路径数目，$s$ 为当前已经走过的路径长度，对于不同的 $s$，$f[i]$ 是不同的，考虑在 $s$ 相同时怎样避免重复搜索 $i$，如果能记录 $f[i][s]$ 就好了，但 $s$ 可以很大，开不了这样的数组。

换种角度，如果第二维与 $k$ 有关系就好了，我们考虑怎样用 $k$ 来表示 $s$，需要用到一个很重要的性质：**符合条件的路径一定不包含 $dis(1,u) > minDis(1, u) + k$**，而 $s$ 肯定是大于 $minDis(1,u)$ 的，所以 $s$ 就可以表示成 $minDis(1,u) + j, 0 <= j <= k$。用 $f[i][j]$ 来表示状态。

```c++
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <cstring>

const int N = 100005;
struct Edge {
	int to, cost;
};
struct Node {
	int x, y;
	bool operator > (const Node &cmp) const {
		return x > cmp.x;
	}
};
std::vector<Edge> edges;
std::vector<int> G[N];
int n, m, k, p, dis[N], instack[N], f[N][55], len[N];
bool flag;

int read() {
	int x = 0; char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return x;
}
void add_edge(int from, int to, int cost) {
	G[from].push_back(edges.size());
	edges.push_back((Edge){to, cost});
}
void dij() {
	std::priority_queue<Node, std::vector<Node>, std::greater<Node> > Q; 
	int vis[N] = {}; memset(dis, 0x3f, sizeof dis); dis[1] = 0; Q.push((Node){0, 1});
	while (!Q.empty()) {
		int u = Q.top().y; Q.pop();
		int sz = G[u].size(); vis[u] = 1;
		for (int i = 0; i < sz; ++i) {
			Edge e = edges[G[u][i]];
			if (!vis[e.to] && dis[u] + e.cost < dis[e.to])
				dis[e.to] = dis[u] + e.cost, Q.push((Node){dis[e.to], e.to});
		}
	}
}
void dfs(int u, int s) {
	instack[u] = 1, len[u] = s;
	if (f[u][s-dis[u]] == -1) f[u][s-dis[u]] = 0;
	if (u == n) ++f[u][s-dis[u]];
	int sz = G[u].size();
	for (int i = 0; i < sz; ++i) {
		Edge e = edges[G[u][i]];
		if (s + e.cost <= dis[e.to] + k) {
			if (instack[e.to] && s - len[e.to] == 0 && e.cost == 0) {
				flag = 1; return;
			}
			int x = s - dis[u], y = s + e.cost - dis[e.to];
			if (f[e.to][y] == -1) dfs(e.to, s + e.cost);
			if (flag) return;
			f[u][x] += f[e.to][y];
			if (f[u][x] >= p) f[u][x] %= p;
		}
	}
	instack[u] = 0;
}

int main() {
	int T = read();
	while (T--) {
		n = read(), m = read(), k = read(), p = read();
		memset(f, -1, sizeof f);
		edges.clear(); flag = 0;
		for (int i = 1; i <= n; ++i) G[i].clear();
		for (int i = 1; i <= m; ++i) {
			int u = read(), v = read(), c = read();
			add_edge(u, v, c);
		}
		dij(); dfs(1, 0);
		if (flag) puts("-1");
		else printf("%d\n", f[1][0]);
	}
	return 0;
}
```
