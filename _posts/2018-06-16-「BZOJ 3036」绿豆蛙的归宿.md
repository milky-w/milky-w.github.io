---
title: 「BZOJ 3036」绿豆蛙的归宿
date: 2018-06-16 21:52:14
categories:
- 概率论
tags:
- 拓扑排序
mathjax: true
---

> 题目大意：给出一个有向无环的连通图，起点为 $1$ 终点为 $N$，每条边都有一个长度。并且从起点出发能够到达所有的点，所有的点也都能够到达终点。绿豆蛙从起点出发，走向终点。到达每一个顶点时，如果有 $K$ 条离开该点的道路，绿豆蛙可以选择任意一条道路离开该点，并且走向每条路的概率为 $1/K$。
现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？$N<=100000，M<=2*N$

<center> 经过路径的期望总长 $=$ $\sum$ 每条边的期望经过次数 $*$ 边权 </center>

<center> 因为是有向无环图，所以 </center>

<center> 每条边的期望经过次数 $=$ 该边起点的期望经过次数 $*$ 从该起点出发经过该路径的概率 </center>

<center> 每个点的期望经过次数 $=$ $\sum$ 入边的期望经过次数 </center>

从 **从起点出发能够到达所有的点，所有的点也都能够到达终点** 入手，拓扑排序就可以解决。

```c++
#include <cstdio>
#include <vector>
#include <queue>

struct Edge {
    int u, v, c;
};
std::vector<Edge> edges;
std::vector<int> G[100005];
int indgr[100005];
double cnt[100005], ans;

int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}

void add_edge(int u, int v, int c) {
    G[u].push_back(edges.size());
    edges.push_back((Edge){u, v, c});
}

int main() {
    int n = read(), m = read();
    for (int i = 1; i <= m; ++i) {
        int u = read(), v = read(), c = read();
        add_edge(u, v, c), ++indgr[v];
    }
    std::queue<int> Q; Q.push(1); cnt[1] = 1;
    while (!Q.empty()) {
        int u = Q.front(); Q.pop();
        int sz = G[u].size();
        for (int i = 0; i < sz; ++i) {
            int v = edges[G[u][i]].v;
            ans += edges[G[u][i]].c * cnt[u] * 1.0 / sz;
            cnt[v] += cnt[u] * 1.0 / sz;
            if (--indgr[v] == 0) Q.push(v);
        }
    }
    printf("%.2lf", ans);
    return 0;
}
```
