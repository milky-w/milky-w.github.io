---
title: 「CQOI 2007」涂色
date: 2018-06-02 18:51:26
categories:
- 动态规划
tags:
- 区间DP
mathjax: true
---

> 题目大意：给定一个长为 $n$ 的大写字母序列，每次可以用同种颜色染连续的一段，后染的可以覆盖，求最少几次能将空白序列染成给定的序列。$1<=n<=50$

一开始写了个鬼畜的贪心，得了 $10$ 分……

$f[i][j]$ 表示将区间 $[i,j]$ 染成目标序列的最少步数。

如果 $s[l]=s[r]$，$f[l][r]=min(f[l+1][r], f[l][r-1])$；

如果 $s[l]=s[l+1]$，$f[l][r]=f[l+1][r]$；

如果 $s[r]=s[r-1]$，$f[l][r]=f[l][r-1]$。

我一开始还在考虑中间有相同颜色的怎么办，才发现我忽略了区间DP的性质，因为在区间DP中，中间两个相同的颜色总有一个时刻分别为左右端点。

最后还要加第三重循环更新一遍。

```c++
#include <cstdio>
#include <cstring>

int f[55][55]; char s[60];

int min(int x, int y) {
	if (x < y) return x; return y;
}

int main() {
	scanf("%s", s+1);
	int n = strlen(s+1);
	for (int i = 1; i <= n; ++i) f[i][i] = 1;
	for (int i = n - 1; i >= 1; --i) {
		for (int j = i + 1; j <= n; ++j) {
			f[i][j] = f[i][j-1] + 1;
			if (s[i] == s[j]) f[i][j] = min(f[i+1][j], f[i][j-1]);
			if (s[i] == s[i+1]) f[i][j] = min(f[i][j], f[i+1][j]);
			if (s[j-1] == s[j]) f[i][j] = min(f[i][j], f[i][j-1]);
			for (int k = i; k < j; ++k) f[i][j] = min(f[i][j], f[i][k] + f[k+1][j]);
		}
	}
	printf("%d\n", f[1][n]);
	return 0;
}
```
