---
title: 「CQOI 2007」涂色
date: 2018-06-02 18:51:26
categories:
- 动态规划
tags:
- 区间DP
mathjax: true
---

> 题目大意：给定一个长为 $n$ 的大写字母序列，每次可以用同种颜色染连续的一段，后染的可以覆盖，求最少几次能将空白序列染成给定的序列。$1<=n<=50$

一开始写了个鬼畜的贪心，得了 $10$ 分……

```c++
#include <cstdio>
#include <cstring>

char s[60];
int n, f[60], ch[30], ans = 1;

int main() {
	scanf("%s", s);
	n = strlen(s), f[0] = 1, ch[s[0]-'A'] = 1;
	for (int i = 1; i < n; ++i) {
		int c = s[i] - 'A';
		if (!ch[c]) f[i] = f[i-1] + 1;
		else {
			bool flag = true;
			for (int j = ch[c]; j < i; ++j)
				if (f[j] < f[ch[c]-1]) { flag = false; break; }
			if (!flag) f[i] = f[i-1] + 1;
			else f[i] = f[ch[c]-1];
		}
		ch[c] = i + 1;
		if (f[i] > ans) ans = f[i];
	}
	printf("%d\n", ans);
	return 0;
}
```

$f[i][j]$ 表示将区间 $[i,j]$ 染成目标序列的最少步数。
