---
title: 「SDOI 2009」HH去散步
date: 2018-06-01 10:34:48
categories:
- 动态规划
tags:
- 矩阵乘法
mathjax: true
---

> 题目大意：已知 $N$ 个点 $M$ 条边，问从 $A$ 走 $t$ 步到 $B$ 有多少种方案。走的过程中不能往回走。$N ≤ 50，M ≤ 60，t ≤ 2^30，0 ≤ A,B$

路径转移方案肯定是矩乘了，如果按照结点建邻接矩阵，不能排除反复走一条边的情况。

所以化边为点，按照边来建立矩阵，将每条无向边拆成两条有向边，将拆成的这两条边的关系设为 $0$，即保证不能直接互相到达，这样就满足了不重复走同一条边。

放上去年的代码：

```c++
#include<cstdio>
#include<cstring>
using namespace std;
 
struct Mat{
    int a[200][200];
}mat,unit; 
 
struct Edge{
    int to,next;
}e[200];
 
int tot,head[100],n;
 
void Add(int from,int to)
{
    e[++tot].next=head[from];
    e[tot].to = to;
    head[from] = tot;
}
 
void bfs()
{
    for(int i=1;i<=tot;++i)
    {
        int now=e[i].to;
        for(int j=head[now];j;j=e[j].next)
        {
            mat.a[i][j]=1;
        }
        if(i&1) mat.a[i][i+1]=0;
        else mat.a[i][i-1]=0;
    }
     
}
 
Mat cheng(Mat a,Mat b)
{
    Mat c;
    memset(c.a,0,sizeof c.a);
    for(int i=1;i<=tot;++i)
        for(int j=1;j<=tot;++j)
            for(int k=1;k<=tot;++k)
            {
                c.a[i][j]+=a.a[i][k]*b.a[k][j];
                if(c.a[i][j]>=45989) c.a[i][j]%=45989;
            }
    return c;
}
 
Mat fast_pow(Mat a,int p)
{
    Mat ans=unit;
    for(;p;p>>=1,a=cheng(a,a))
    {
        if(p&1)
            ans=cheng(ans,a);
    }
    return ans;
}
 
int main()
{
    int t,a,b,m;
    scanf("%d%d%d%d%d",&n,&m,&t,&a,&b);
    for(int i=1;i<=m;++i)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        Add(x+1,y+1);
        Add(y+1,x+1);
    }
    bfs();
    for(int i=1;i<=tot;++i) unit.a[i][i]=1;
    mat=fast_pow(mat,t-1);
    int ans=0;
    for(int i=head[a+1];i;i=e[i].next)
    {
        for(int j=head[b+1];j;j=e[j].next)
        {
            if(j&1) ans+=mat.a[i][j+1];
            else ans+=mat.a[i][j-1];
            if(ans>=45989) ans%=45989;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
