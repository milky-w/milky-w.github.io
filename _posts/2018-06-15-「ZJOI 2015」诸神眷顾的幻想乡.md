---
title: 「ZJOI 2015」诸神眷顾的幻想乡
date: 2018-06-15 16:54:59
categories:
- 字符串
tags:
- 后缀自动机
mathjax: true
---

> 题目大意：给定一棵树，每个节点有一个颜色，问树上有多少种子串（定义子串为某两个点上的路径），保证叶子节点数$<=20$。$n<=10^5$

“只与一个空地相邻的空地数量不超过 $20$ 个”也就是最多有 $20$ 个叶子结点，以每个叶子结点为根构建后缀自动机，所有不同子串的个数即为答案（$SAM$ 中的串都是不相同的子串）。

- **多棵字符串树建到同一个 $SAM$ 中，以保证全部子串互不相同；**
- **$dfs$ 序构建广义 $SAM$ 的 $pre$ 结点是 $dfs$ 树上的父结点；**

```c++
#include <cstdio>
#include <vector>
#include <cstring>

const int N = 2000005;
int sz = 1, L[N], ch[N][10], fa[N];
int color[100005], dgr[100005];
std::vector<int> G[100005];

int read() {
	int x = 0; char c = getchar();
	while (c < '0' || c > '9') c = getchar();
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return x;
}
int insert(int c, int p) {
	int np = ++sz; L[np] = L[p] + 1;
	for (; p && !ch[p][c]; p = fa[p]) ch[p][c] = np;
	if (!p) fa[np] = 1;
	else {
		int q = ch[p][c];
		if (L[q] == L[p] + 1) fa[np] = q;
		else {
			int nq = ++sz; L[nq] = L[p] + 1;
			memcpy(ch[nq], ch[q], sizeof ch[q]);
			fa[nq] = fa[q], fa[q] = fa[np] = nq;
			for (; p && ch[p][c] == q; p = fa[p]) ch[p][c] = nq;
		}
	}
	return np;
}
void dfs(int u, int fa, int pre) {
	int now = insert(color[u], pre); //广义SAM记录前驱结点 
	int sz = G[u].size();
	for (int i = 0; i < sz; ++i)
		if (G[u][i] != fa) dfs(G[u][i], u, now);
}

int main() {
	int n = read(), c = read();
	for (int i = 1; i <= n; ++i) color[i] = read();
	for (int i = 1; i < n; ++i) {
		int u = read(), v = read();
		G[u].push_back(v), ++dgr[u];
		G[v].push_back(u), ++dgr[v];
	}
	for (int i = 1; i <= n; ++i)
		if (dgr[i] == 1) dfs(i, 0, 1);
	long long ans = 0;
	for (int i = 1; i <= sz; ++i)
		ans += L[i] - L[fa[i]];
	printf("%lld\n", ans);
	return 0;
}
```
